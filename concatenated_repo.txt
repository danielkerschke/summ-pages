REPOSITORY CONCATENATION
========================
Repository: D:\RA\summ-pages
Generated: 2025-07-26 00:30:58
Max file size limit: 50,000 characters

================================================================================
FILE: _includes\sidenote.html
SUMMARY: Location: _includes | Type: html file
================================================================================

<aside class="sidenote">
  {{ include.text }}
</aside>


================================================================================
FILE: _layouts\default.html
SUMMARY: Location: _layouts | Type: html file
================================================================================

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>{{ page.title | default: site.title }}</title>
  
  <!-- Loads the EB Garamond font from Google Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,700;1,400&display=swap" rel="stylesheet">
  
  <!-- Links to your stylesheet using the robust relative_url method -->
  <link rel="stylesheet" href="{{ '/assets/css/style.css' | relative_url }}">
</head>
<body>
  <div class="page-wrapper">
    <header>
      <h1>My Awesome Website</h1>
    </header>

    <!-- The main wrapper that enables the two-column grid -->
    <main class="content-with-sidenotes">
      {{ content }}
    </main>

    <footer>
      <p>© 2023 Your Name</p>
    </footer>
  </div>
</body>
</html>


================================================================================
FILE: assets\css\style.scss
SUMMARY: Location: assets / css | Type: scss file
================================================================================

---
---
// The two "---" lines above are required by Jekyll to process the file.

/* --- FONT & BODY STYLING --- */

body {
  font-family: 'EB Garamond', serif; 
  line-height: 1.6;
  color: #333;
  margin: 0;
  padding: 2rem;
}
.page-wrapper {
  max-width: 1200px;
  margin: 0 auto;
}

/* --- SIDENOTE LAYOUT CSS --- */

// 1. The main grid container
.content-with-sidenotes {
  display: grid;
  grid-template-columns: 200px 1fr;
  grid-column-gap: 40px;
  align-items: start;
}

// 2. Place all headings across BOTH columns.
.content-with-sidenotes > h1,
.content-with-sidenotes > h2,
.content-with-sidenotes > h3 {
  grid-column: 1 / -1; // THIS IS THE FIX: makes headings full-width.
}

// 3. Place paragraphs ONLY in the second column.
.content-with-sidenotes > p {
  grid-column: 2;
}

// 4. Style the sidenote itself.
.sidenote {
  grid-column: 1;
  text-align: right;
  font-size: 1.1em;
  font-style: italic;
  color: #555;
  transform: rotate(-6deg);
  transform-origin: top right;
}

// 5. Responsive styling for mobile
@media (max-width: 900px) {
  .content-with-sidenotes {
    display: block; 
  }

  .sidenote {
    text-align: left;
    margin: 1em 0;
    padding: 1em;
    background-color: #f8f8f8;
    border-left: 5px solid #ccc;
    transform: none;
  }
}


================================================================================
FILE: books\lieberman.md
SUMMARY: Location: books | Type: md file
================================================================================

---
layout: default
title: "The Story of the Human Body"
---

This book begins with a puzzle. We live in paradoxical times for our bodies. On one hand, this is likely the healthiest era in human history. In many parts of the world, diseases that once killed in droves—smallpox, the plague, polio—have been conquered or quelled. We can reasonably expect our children to survive to adulthood, and for us to live into our dotage. Formerly life-threatening conditions like a broken leg or appendicitis are now easily remedied. Yet, on the other hand, we could be doing much better. A wave of chronic, preventable illnesses is sweeping the globe. These are not the ancient infectious scourges, but modern ailments: type 2 diabetes, heart disease, certain cancers, osteoporosis, but also a host of less deadly but debilitating troubles like lower back pain, anxiety, and myopia. These aren't just diseases of old age; they are increasingly appearing in middle-aged people. How can our time be both a golden age for health and a burgeoning crisis of chronic disease?

{% include sidenote.html text="Modern health good. But new diseases rising. Why both at once?" %}

The author, a professor of human evolutionary biology, argues that this paradox stems from a fundamental misunderstanding of our own bodies. The key lies in an idea best illustrated by a story from the source text: the "Mystery Monkey" of Tampa, Florida. This macaque lived for years on city streets, evading capture. While most people saw it as an animal out of place, an anomaly in a suburban environment, they rarely apply the same logic to themselves. From an evolutionary perspective, a human living in a modern city, surrounded by cars, processed food, and air-conditioning, is just as far removed from their ancestral environment as that monkey. Our bodies, the product of millions of years of evolution in environments of scarcity and physical hardship, are now operating in a world of unprecedented abundance and comfort. This profound mismatch between our ancient biology and our modern lives is the engine driving the chronic diseases that plague us.

{% include sidenote.html text="Monkey in city is weird. Human in city is also weird. Our old bodies don't fit our new world. This mismatch causes sickness." %}

This naturally leads to the question at the heart of the book: *What are human bodies adapted for?* The answer is more complex and less intuitive than it first appears. It’s tempting to think of adaptation in terms of perfection or optimality for a specific lifestyle, like that of a Stone Age hunter-gatherer. This logic fuels trends like the "paleodiet." But this view misunderstands what adaptation means in biology. Natural selection does not shape organisms to be healthy, long-lived, or happy. It shapes them for one primary purpose: reproductive success. Adaptations are simply heritable traits that, in a particular environment, helped an individual’s ancestors have more surviving offspring than their competitors. A craving for sugar and fat was a superb adaptation when calories were scarce and starvation was a constant threat; it helped our ancestors store energy and survive to reproduce. In a modern supermarket, that same inherited craving becomes a direct path to obesity and diabetes. The adaptation itself is not "good" or "bad"; its value is entirely dependent on the context.

{% include sidenote.html text="Adaptation is not for health. It's for making babies. Sweet tooth good then, bad now. Context changed everything." %}

Furthermore, the human body is not a perfectly engineered machine, but a palimpsest—an old manuscript page written on over and over again. Each stage of our evolutionary history has layered new adaptations on top of older ones, creating a jumble of compromises. Our teeth, inherited from fruit-eating ape ancestors, are superb for chewing figs but terrible for gnawing raw meat. Our upright posture, which freed our hands, also gave us weak lower backs prone to aching. There was no single environment for which the human body is "optimally" designed. To understand what we are adapted for is to understand this entire, messy history, not just a snapshot from the late Stone Age. The author suggests this history can be understood through a series of major transformations, which function as the book's narrative spine.

{% include sidenote.html text="Body is not perfect design. It's a messy stack of old parts. Ape teeth, biped back. Full of compromises from long history." %}

The book charts this history through five major biological transitions. It begins with the first human ancestors diverging from apes and evolving to be upright bipeds. This was followed by the evolution of the australopiths, who developed adaptations to eat a much wider range of foods beyond fruit. About two million years ago, the first members of our own genus, *Homo*, evolved nearly modern bodies and bigger brains, becoming the first hunter-gatherers. As these archaic humans spread, they evolved even larger brains and slower-growing bodies. Finally, the fifth transition was the evolution of modern humans, *Homo sapiens*, with our unique capacities for language, culture, and cooperation, which allowed us to become the sole surviving human species on the planet.

{% include sidenote.html text="The story of us: walking upright, eating everything, hunting and gathering, getting big brains, then getting culture." %}

However, the story does not end there. Evolution is not just a study of the past; it is an ongoing process. And for humans, the most powerful evolutionary force today is not biological, but cultural. Biological evolution is slow, passing changes through genes from parent to child. Cultural evolution is lightning-fast, passing new ideas and behaviors between any individuals. Two cultural revolutions have been so transformative that they amount to a sixth and seventh transition. The Agricultural Revolution, starting around 10,000 years ago, radically changed our diet and settlement patterns. More recently, the Industrial Revolution began to replace human labor with machines, further altering how we work, live, and interact. These cultural shifts have created the novel environments our bodies are now struggling with.

{% include sidenote.html text="Evolution isn't over. Culture evolves faster than genes. Farming and factories changed our world faster than our bodies could keep up." %}

This sets up the book's central argument: we are caught in a feedback loop, a dynamic the author calls "dysevolution." First, our rapid cultural evolution creates novel environments we are poorly adapted for. Second, this mismatch causes chronic, noninfectious diseases. Third, for various reasons—be it difficulty, cost, or a lack of understanding—we often fail to address the root environmental causes of these diseases. Instead, we use our cultural ingenuity (medicine, technology) to treat the symptoms. This allows the underlying mismatch to persist and even worsen, as we pass on the disease-causing environments and behaviors to the next generation. Understanding this loop—the intricate dance between our ancient, inherited bodies and our rapidly evolving culture—is the key not only to making sense of modern illness, but to finding a way to a healthier future.

{% include sidenote.html text="Culture creates new worlds. Our old bodies get sick in them. We treat sickness, not the cause. The sickness-loop continues." %}


================================================================================
FILE: concatenate_repo.py
SUMMARY: Type: py file
================================================================================

#!/usr/bin/env python3
"""
Repository File Concatenator
Recursively scans a repository and concatenates all files with metadata
for easy AI context sharing.
"""

import os
import argparse
from pathlib import Path
import mimetypes
from datetime import datetime

# File extensions to include (text-based files)
TEXT_EXTENSIONS = {
    '.py', '.js', '.ts', '.jsx', '.tsx', '.html', '.css', '.scss', '.sass',
    '.json', '.xml', '.yaml', '.yml', '.toml', '.ini', '.cfg', '.conf',
    '.md', '.txt', '.rst', '.tex', '.csv', '.sql', '.sh', '.bash', '.zsh',
    '.ps1', '.bat', '.cmd', '.dockerfile', '.gitignore', '.gitattributes',
    '.env', '.example', '.sample', '.template', '.makefile', '.cmake',
    '.c', '.cpp', '.h', '.hpp', '.cs', '.java', '.php', '.rb', '.go',
    '.rs', '.swift', '.kt', '.scala', '.clj', '.hs', '.ml', '.r', '.m',
    '.vim', '.lua', '.pl', '.tcl', '.awk', '.sed', '.grep'
}

# Directories to ignore
IGNORE_DIRS = {
    '.git', '.svn', '.hg', '__pycache__', 'node_modules', '.venv', 'venv',
    'env', '.env', 'dist', 'build', '.next', '.nuxt', 'target', 'bin',
    'obj', '.vs', '.vscode', '.idea', '*.egg-info', '.pytest_cache',
    '.coverage', '.nyc_output', 'coverage', '.DS_Store', 'Thumbs.db'
}

# Files to ignore
IGNORE_FILES = {
    '.DS_Store', 'Thumbs.db', '*.pyc', '*.pyo', '*.pyd', '*.class',
    '*.o', '*.so', '*.dylib', '*.dll', '*.exe', '*.log', '*.tmp',
    '*.temp', '*.bak', '*.backup', '*.swp', '*.swo', '*~'
}

def is_text_file(file_path):
    """Check if a file is likely a text file based on extension and mimetype."""
    # Check extension first
    if file_path.suffix.lower() in TEXT_EXTENSIONS:
        return True
    
    # Check if it has no extension but might be a text file
    if not file_path.suffix:
        try:
            # Try to detect mimetype
            mime_type, _ = mimetypes.guess_type(str(file_path))
            if mime_type and mime_type.startswith('text/'):
                return True
            
            # For files without extension, try reading first few bytes
            with open(file_path, 'rb') as f:
                sample = f.read(1024)
                # Check if it's mostly text (allow some binary chars)
                try:
                    sample.decode('utf-8')
                    return True
                except UnicodeDecodeError:
                    return False
        except:
            return False
    
    return False

def should_ignore_path(path, ignore_dirs, ignore_files):
    """Check if a path should be ignored."""
    path_name = path.name.lower()
    
    # Check if it's an ignored directory
    if path.is_dir() and path_name in ignore_dirs:
        return True
    
    # Check if it's an ignored file
    if path.is_file() and path_name in ignore_files:
        return True
    
    return False

def get_file_summary(file_path):
    """Generate a brief summary of the file based on its name and location."""
    relative_path = file_path
    parts = relative_path.parts
    
    # Extract meaningful information from path
    summary_parts = []
    
    # Add directory context
    if len(parts) > 1:
        dir_context = " / ".join(parts[:-1])
        summary_parts.append(f"Location: {dir_context}")
    
    # Add file type information
    if file_path.suffix:
        summary_parts.append(f"Type: {file_path.suffix[1:]} file")
    
    # Add special file recognition
    filename = file_path.name.lower()
    if filename in ['readme.md', 'readme.txt', 'readme']:
        summary_parts.append("Purpose: Documentation/README")
    elif filename in ['package.json', 'requirements.txt', 'pyproject.toml', 'cargo.toml']:
        summary_parts.append("Purpose: Package/Dependencies configuration")
    elif filename in ['dockerfile', 'docker-compose.yml']:
        summary_parts.append("Purpose: Container configuration")
    elif filename.startswith('.'):
        summary_parts.append("Purpose: Configuration/Hidden file")
    elif 'test' in filename or 'spec' in filename:
        summary_parts.append("Purpose: Test file")
    elif 'config' in filename or 'settings' in filename:
        summary_parts.append("Purpose: Configuration file")
    
    return " | ".join(summary_parts) if summary_parts else "Regular file"

def read_file_content(file_path):
    """Safely read file content with encoding detection."""
    encodings = ['utf-8', 'utf-16', 'latin-1', 'cp1252']
    
    for encoding in encodings:
        try:
            with open(file_path, 'r', encoding=encoding) as f:
                return f.read()
        except (UnicodeDecodeError, UnicodeError):
            continue
        except Exception as e:
            return f"[ERROR: Could not read file - {str(e)}]"
    
    return "[ERROR: Could not decode file with any supported encoding]"

def concatenate_repository(repo_path, output_file=None, max_file_size=50000):
    """Main function to concatenate all repository files."""
    repo_path = Path(repo_path).resolve()
    
    if not repo_path.exists():
        print(f"Error: Repository path '{repo_path}' does not exist.")
        return
    
    if not repo_path.is_dir():
        print(f"Error: '{repo_path}' is not a directory.")
        return
    
    # Determine output file
    if output_file is None:
        output_file = repo_path / "concatenated_repo.txt"
    else:
        output_file = Path(output_file)
    
    print(f"Scanning repository: {repo_path}")
    print(f"Output file: {output_file}")
    
    files_processed = 0
    files_skipped = 0
    total_size = 0
    
    with open(output_file, 'w', encoding='utf-8') as out_f:
        # Write header
        out_f.write(f"REPOSITORY CONCATENATION\n")
        out_f.write(f"========================\n")
        out_f.write(f"Repository: {repo_path}\n")
        out_f.write(f"Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
        out_f.write(f"Max file size limit: {max_file_size:,} characters\n\n")
        
        # Recursively walk through all files
        for file_path in sorted(repo_path.rglob('*')):
            # Skip if path should be ignored
            relative_path = file_path.relative_to(repo_path)
            
            # Check if any part of the path should be ignored
            should_skip = False
            for part in relative_path.parts:
                if part.lower() in IGNORE_DIRS or part.lower() in IGNORE_FILES:
                    should_skip = True
                    break
            
            if should_skip:
                continue
            
            # Only process files
            if not file_path.is_file():
                continue
            
            # Only process text files
            if not is_text_file(file_path):
                files_skipped += 1
                continue
            
            try:
                # Get relative path for display
                relative_path = file_path.relative_to(repo_path)
                
                # Read file content
                content = read_file_content(file_path)
                
                # Check file size
                if len(content) > max_file_size:
                    content = content[:max_file_size] + f"\n\n[TRUNCATED - File too large, showing first {max_file_size:,} characters]"
                
                # Generate summary
                summary = get_file_summary(relative_path)
                
                # Write file section
                out_f.write("=" * 80 + "\n")
                out_f.write(f"FILE: {relative_path}\n")
                out_f.write(f"SUMMARY: {summary}\n")
                out_f.write("=" * 80 + "\n\n")
                out_f.write(content)
                out_f.write("\n\n")
                
                files_processed += 1
                total_size += len(content)
                
                # Progress indicator
                if files_processed % 10 == 0:
                    print(f"Processed {files_processed} files...")
                    
            except Exception as e:
                print(f"Error processing {file_path}: {str(e)}")
                files_skipped += 1
        
        # Write footer
        out_f.write("=" * 80 + "\n")
        out_f.write("CONCATENATION COMPLETE\n")
        out_f.write("=" * 80 + "\n")
        out_f.write(f"Files processed: {files_processed}\n")
        out_f.write(f"Files skipped: {files_skipped}\n")
        out_f.write(f"Total content size: {total_size:,} characters\n")
    
    print(f"\nConcatenation complete!")
    print(f"Files processed: {files_processed}")
    print(f"Files skipped: {files_skipped}")
    print(f"Output saved to: {output_file}")
    print(f"Total size: {total_size:,} characters")

def main():
    parser = argparse.ArgumentParser(
        description="Concatenate all text files in a repository for AI context sharing"
    )
    parser.add_argument(
        "repo_path", 
        help="Path to the repository directory"
    )
    parser.add_argument(
        "-o", "--output", 
        help="Output file path (default: auto-generated in repo directory)"
    )
    parser.add_argument(
        "--max-size", 
        type=int, 
        default=50000,
        help="Maximum file size in characters before truncation (default: 50000)"
    )
    
    args = parser.parse_args()
    
    concatenate_repository(args.repo_path, args.output, args.max_size)

if __name__ == "__main__":
    main()

================================================================================
FILE: concatenated_repo.txt
SUMMARY: Type: txt file
================================================================================

REPOSITORY CONCATENATION
========================
Repository: D:\RA\summ-pages
Generated: 2025-07-26 00:30:58
Max file size limit: 50,000 characters

================================================================================
FILE: _includes\sidenote.html
SUMMARY: Location: _includes | Type: html file
================================================================================

<aside class="sidenote">
  {{ include.text }}
</aside>


================================================================================
FILE: _layouts\default.html
SUMMARY: Location: _layouts | Type: html file
================================================================================

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>{{ page.title | default: site.title }}</title>
  
  <!-- Loads the EB Garamond font from Google Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,700;1,400&display=swap" rel="stylesheet">
  
  <!-- Links to your stylesheet using the robust relative_url method -->
  <link rel="stylesheet" href="{{ '/assets/css/style.css' | relative_url }}">
</head>
<body>
  <div class="page-wrapper">
    <header>
      <h1>My Awesome Website</h1>
    </header>

    <!-- The main wrapper that enables the two-column grid -->
    <main class="content-with-sidenotes">
      {{ content }}
    </main>

    <footer>
      <p>© 2023 Your Name</p>
    </footer>
  </div>
</body>
</html>


================================================================================
FILE: assets\css\style.scss
SUMMARY: Location: assets / css | Type: scss file
================================================================================

---
---
// The two "---" lines above are required by Jekyll to process the file.

/* --- FONT & BODY STYLING --- */

body {
  font-family: 'EB Garamond', serif; 
  line-height: 1.6;
  color: #333;
  margin: 0;
  padding: 2rem;
}
.page-wrapper {
  max-width: 1200px;
  margin: 0 auto;
}

/* --- SIDENOTE LAYOUT CSS --- */

// 1. The main grid container
.content-with-sidenotes {
  display: grid;
  grid-template-columns: 200px 1fr;
  grid-column-gap: 40px;
  align-items: start;
}

// 2. Place all headings across BOTH columns.
.content-with-sidenotes > h1,
.content-with-sidenotes > h2,
.content-with-sidenotes > h3 {
  grid-column: 1 / -1; // THIS IS THE FIX: makes headings full-width.
}

// 3. Place paragraphs ONLY in the second column.
.content-with-sidenotes > p {
  grid-column: 2;
}

// 4. Style the sidenote itself.
.sidenote {
  grid-column: 1;
  text-align: right;
  font-size: 1.1em;
  font-style: italic;
  color: #555;
  transform: rotate(-6deg);
  transform-origin: top right;
}

// 5. Responsive styling for mobile
@media (max-width: 900px) {
  .content-with-sidenotes {
    display: block; 
  }

  .sidenote {
    text-align: left;
    margin: 1em 0;
    padding: 1em;
    background-color: #f8f8f8;
    border-left: 5px solid #ccc;
    transform: none;
  }
}


================================================================================
FILE: books\lieberman.md
SUMMARY: Location: books | Type: md file
================================================================================

---
layout: default
title: "The Story of the Human Body"
---

This book begins with a puzzle. We live in paradoxical times for our bodies. On one hand, this is likely the healthiest era in human history. In many parts of the world, diseases that once killed in droves—smallpox, the plague, polio—have been conquered or quelled. We can reasonably expect our children to survive to adulthood, and for us to live into our dotage. Formerly life-threatening conditions like a broken leg or appendicitis are now easily remedied. Yet, on the other hand, we could be doing much better. A wave of chronic, preventable illnesses is sweeping the globe. These are not the ancient infectious scourges, but modern ailments: type 2 diabetes, heart disease, certain cancers, osteoporosis, but also a host of less deadly but debilitating troubles like lower back pain, anxiety, and myopia. These aren't just diseases of old age; they are increasingly appearing in middle-aged people. How can our time be both a golden age for health and a burgeoning crisis of chronic disease?

{% include sidenote.html text="Modern health good. But new diseases rising. Why both at once?" %}

The author, a professor of human evolutionary biology, argues that this paradox stems from a fundamental misunderstanding of our own bodies. The key lies in an idea best illustrated by a story from the source text: the "Mystery Monkey" of Tampa, Florida. This macaque lived for years on city streets, evading capture. While most people saw it as an animal out of place, an anomaly in a suburban environment, they rarely apply the same logic to themselves. From an evolutionary perspective, a human living in a modern city, surrounded by cars, processed food, and air-conditioning, is just as far removed from their ancestral environment as that monkey. Our bodies, the product of millions of years of evolution in environments of scarcity and physical hardship, are now operating in a world of unprecedented abundance and comfort. This profound mismatch between our ancient biology and our modern lives is the engine driving the chronic diseases that plague us.

{% include sidenote.html text="Monkey in city is weird. Human in city is also weird. Our old bodies don't fit our new world. This mismatch causes sickness." %}

This naturally leads to the question at the heart of the book: *What are human bodies adapted for?* The answer is more complex and less intuitive than it first appears. It’s tempting to think of adaptation in terms of perfection or optimality for a specific lifestyle, like that of a Stone Age hunter-gatherer. This logic fuels trends like the "paleodiet." But this view misunderstands what adaptation means in biology. Natural selection does not shape organisms to be healthy, long-lived, or happy. It shapes them for one primary purpose: reproductive success. Adaptations are simply heritable traits that, in a particular environment, helped an individual’s ancestors have more surviving offspring than their competitors. A craving for sugar and fat was a superb adaptation when calories were scarce and starvation was a constant threat; it helped our ancestors store energy and survive to reproduce. In a modern supermarket, that same inherited craving becomes a direct path to obesity and diabetes. The adaptation itself is not "good" or "bad"; its value is entirely dependent on the context.

{% include sidenote.html text="Adaptation is not for health. It's for making babies. Sweet tooth good then, bad now. Context changed everything." %}

Furthermore, the human body is not a perfectly engineered machine, but a palimpsest—an old manuscript page written on over and over again. Each stage of our evolutionary history has layered new adaptations on top of older ones, creating a jumble of compromises. Our teeth, inherited from fruit-eating ape ancestors, are superb for chewing figs but terrible for gnawing raw meat. Our upright posture, which freed our hands, also gave us weak lower backs prone to aching. There was no single environment for which the human body is "optimally" designed. To understand what we are adapted for is to understand this entire, messy history, not just a snapshot from the late Stone Age. The author suggests this history can be understood through a series of major transformations, which function as the book's narrative spine.

{% include sidenote.html text="Body is not perfect design. It's a messy stack of old parts. Ape teeth, biped back. Full of compromises from long history." %}

The book charts this history through five major biological transitions. It begins with the first human ancestors diverging from apes and evolving to be upright bipeds. This was followed by the evolution of the australopiths, who developed adaptations to eat a much wider range of foods beyond fruit. About two million years ago, the first members of our own genus, *Homo*, evolved nearly modern bodies and bigger brains, becoming the first hunter-gatherers. As these archaic humans spread, they evolved even larger brains and slower-growing bodies. Finally, the fifth transition was the evolution of modern humans, *Homo sapiens*, with our unique capacities for language, culture, and cooperation, which allowed us to become the sole surviving human species on the planet.

{% include sidenote.html text="The story of us: walking upright, eating everything, hunting and gathering, getting big brains, then getting culture." %}

However, the story does not end there. Evolution is not just a study of the past; it is an ongoing process. And for humans, the most powerful evolutionary force today is not biological, but cultural. Biological evolution is slow, passing changes through genes from parent to child. Cultural evolution is lightning-fast, passing new ideas and behaviors between any individuals. Two cultural revolutions have been so transformative that they amount to a sixth and seventh transition. The Agricultural Revolution, starting around 10,000 years ago, radically changed our diet and settlement patterns. More recently, the Industrial Revolution began to replace human labor with machines, further altering how we work, live, and interact. These cultural shifts have created the novel environments our bodies are now struggling with.

{% include sidenote.html text="Evolution isn't over. Culture evolves faster than genes. Farming and factories changed our world faster than our bodies could keep up." %}

This sets up the book's central argument: we are caught in a feedback loop, a dynamic the author calls "dysevolution." First, our rapid cultural evolution creates novel environments we are poorly adapted for. Second, this mismatch causes chronic, noninfectious diseases. Third, for various reasons—be it difficulty, cost, or a lack of understanding—we often fail to address the root environmental causes of these diseases. Instead, we use our cultural ingenuity (medicine, technology) to treat the symptoms. This allows the underlying mismatch to persist and even worsen, as we pass on the disease-causing environments and behaviors to the next generation. Understanding this loop—the intricate dance between our ancient, inherited bodies and our rapidly evolving culture—is the key not only to making sense of modern illness, but to finding a way to a healthier future.

{% include sidenote.html text="Culture creates new worlds. Our old bodies get sick in them. We treat sickness, not the cause. The sickness-loop continues." %}


================================================================================
FILE: concatenate_repo.py
SUMMARY: Type: py file
================================================================================

#!/usr/bin/env python3
"""
Repository File Concatenator
Recursively scans a repository and concatenates all files with metadata
for easy AI context sharing.
"""

import os
import argparse
from pathlib import Path
import mimetypes
from datetime import datetime

# File extensions to include (text-based files)
TEXT_EXTENSIONS = {
    '.py', '.js', '.ts', '.jsx', '.tsx', '.html', '.css', '.scss', '.sass',
    '.json', '.xml', '.yaml', '.yml', '.toml', '.ini', '.cfg', '.conf',
    '.md', '.txt', '.rst', '.tex', '.csv', '.sql', '.sh', '.bash', '.zsh',
    '.ps1', '.bat', '.cmd', '.dockerfile', '.gitignore', '.gitattributes',
    '.env', '.example', '.sample', '.template', '.makefile', '.cmake',
    '.c', '.cpp', '.h', '.hpp', '.cs', '.java', '.php', '.rb', '.go',
    '.rs', '.swift', '.kt', '.scala', '.clj', '.hs', '.ml', '.r', '.m',
    '.vim', '.lua', '.pl', '.tcl', '.awk', '.sed', '.grep'
}

# Directories to ignore
IGNORE_DIRS = {
    '.git', '.svn', '.hg', '__pycache__', 'node_modules', '.venv', 'venv',
    'env', '.env', 'dist', 'build', '.next', '.nuxt', 'target', 'bin',
    'obj', '.vs', '.vscode', '.idea', '*.egg-info', '.pytest_cache',
    '.coverage', '.nyc_output', 'coverage', '.DS_Store', 'Thumbs.db'
}

# Files to ignore
IGNORE_FILES = {
    '.DS_Store', 'Thumbs.db', '*.pyc', '*.pyo', '*.pyd', '*.class',
    '*.o', '*.so', '*.dylib', '*.dll', '*.exe', '*.log', '*.tmp',
    '*.temp', '*.bak', '*.backup', '*.swp', '*.swo', '*~'
}

def is_text_file(file_path):
    """Check if a file is likely a text file based on extension and mimetype."""
    # Check extension first
    if file_path.suffix.lower() in TEXT_EXTENSIONS:
        return True
    
    # Check if it has no extension but might be a text file
    if not file_path.suffix:
        try:
            # Try to detect mimetype
            mime_type, _ = mimetypes.guess_type(str(file_path))
            if mime_type and mime_type.startswith('text/'):
                return True
            
            # For files without extension, try reading first few bytes
            with open(file_path, 'rb') as f:
                sample = f.read(1024)
                # Check if it's mostly text (allow some binary chars)
                try:
                    sample.decode('utf-8')
                    return True
                except UnicodeDecodeError:
                    return False
        except:
            return False
    
    return False

def should_ignore_path(path, ignore_dirs, ignore_files):
    """Check if a path should be ignored."""
    path_name = path.name.lower()
    
    # Check if it's an ignored directory
    if path.is_dir() and path_name in ignore_dirs:
        return True
    
    # Check if it's an ignored file
    if path.is_file() and path_name in ignore_files:
        return True
    
    return False

def get_file_summary(file_path):
    """Generate a brief summary of the file based on its name and location."""
    relative_path = file_path
    parts = relative_path.parts
    
    # Extract meaningful information from path
    summary_parts = []
    
    # Add directory context
    if len(parts) > 1:
        dir_context = " / ".join(parts[:-1])
        summary_parts.append(f"Location: {dir_context}")
    
    # Add file type information
    if file_path.suffix:
        summary_parts.append(f"Type: {file_path.suffix[1:]} file")
    
    # Add special file recognition
    filename = file_path.name.lower()
    if filename in ['readme.md', 'readme.txt', 'readme']:
        summary_parts.append("Purpose: Documentation/README")
    elif filename in ['package.json', 'requirements.txt', 'pyproject.toml', 'cargo.toml']:
        summary_parts.append("Purpose: Package/Dependencies configuration")
    elif filename in ['dockerfile', 'docker-compose.yml']:
        summary_parts.append("Purpose: Container configuration")
    elif filename.startswith('.'):
        summary_parts.append("Purpose: Configuration/Hidden file")
    elif 'test' in filename or 'spec' in filename:
        summary_parts.append("Purpose: Test file")
    elif 'config' in filename or 'settings' in filename:
        summary_parts.append("Purpose: Configuration file")
    
    return " | ".join(summary_parts) if summary_parts else "Regular file"

def read_file_content(file_path):
    """Safely read file content with encoding detection."""
    encodings = ['utf-8', 'utf-16', 'latin-1', 'cp1252']
    
    for encoding in encodings:
        try:
            with open(file_path, 'r', encoding=encoding) as f:
                return f.read()
        except (UnicodeDecodeError, UnicodeError):
            continue
        except Exception as e:
            return f"[ERROR: Could not read file - {str(e)}]"
    
    return "[ERROR: Could not decode file with any supported encoding]"

def concatenate_repository(repo_path, output_file=None, max_file_size=50000):
    """Main function to concatenate all repository files."""
    repo_path = Path(repo_path).resolve()
    
    if not repo_path.exists():
        print(f"Error: Repository path '{repo_path}' does not exist.")
        return
    
    if not repo_path.is_dir():
        print(f"Error: '{repo_path}' is not a directory.")
        return
    
    # Determine output file
    if output_file is None:
        output_file = repo_path / "concatenated_repo.txt"
    else:
        output_file = Path(output_file)
    
    print(f"Scanning repository: {repo_path}")
    print(f"Output file: {output_file}")
    
    files_processed = 0
    files_skipped = 0
    total_size = 0
    
    with open(output_file, 'w', encoding='utf-8') as out_f:
        # Write header
        out_f.write(f"REPOSITORY CONCATENATION\n")
        out_f.write(f"========================\n")
        out_f.write(f"Repository: {repo_path}\n")
        out_f.write(f"Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
        out_f.write(f"Max file size limit: {max_file_size:,} characters\n\n")
        
        # Recursively walk through all files
        for file_path in sorted(repo_path.rglob('*')):
            # Skip if path should be ignored
            relative_path = file_path.relative_to(repo_path)
            
            # Check if any part of the path should be ignored
            should_skip = False
            for part in relative_path.parts:
                if part.lower() in IGNORE_DIRS or part.lower() in IGNORE_FILES:
                    should_skip = True
                    break
            
            if should_skip:
                continue
            
            # Only process files
            if not file_path.is_file():
                continue
            
            # Only process text files
            if not is_text_file(file_path):
                files_skipped += 1
                continue
            
            try:
                # Get relative path for display
                relative_path = file_path.relative_to(repo_path)
                
                # Read file content
                content = read_file_content(file_path)
                
                # Check file size
                if len(content) > max_file_size:
                    content = content[:max_file_size] + f"\n\n[TRUNCATED - File too large, showing first {max_file_size:,} characters]"
                
                # Generate summary
                summary = get_file_summary(relative_path)
                
                # Write file section
                out_f.write("=" * 80 + "\n")
                out_f.write(f"FILE: {relative_path}\n")
                out_f.write(f"SUMMARY: {summary}\n")
                out_f.write("=" * 80 + "\n\n")
                out_f.write(content)
                out_f.write("\n\n")
                
                files_processed += 1
                total_size += len(content)
                
                # Progress indicator
                if files_processed % 10 == 0:
                    print(f"Processed {files_processed} files...")
                    
            except Exception as e:
                print(f"Error processing {file_path}: {str(e)}")
                files_skipped += 1
        
        # Write footer
        out_f.write("=" * 80 + "\n")
        out_f.write("CONCATENATION COMPLETE\n")
        out_f.write("=" * 80 + "\n")
        out_f.write(f"Files processed: {files_processed}\n")
        out_f.write(f"Files skipped: {files_skipped}\n")
        out_f.write(f"Total content size: {total_size:,} characters\n")
    
    print(f"\nConcatenation complete!")
    print(f"Files processed: {files_processed}")
    print(f"Files skipped: {files_skipped}")
    print(f"Output saved to: {output_file}")
    print(f"Total size: {total_size:,} characters")

def main():
    parser = argparse.ArgumentParser(
        description="Concatenate all text files in a repository for AI context sharing"
    )
    parser.add_argument(
        "repo_path", 
        help="Path to the repository directory"
    )
    parser.add_argument(
        "-o", "--output", 
        help="Output file path (default: auto-generated in repo directory)"
    )
    parser.add_argument(
        "--max-size", 
        type=int, 
        default=50000,
        help="Maximum file size in characters before truncation (default: 50000)"
    )
    
    args = parser.parse_args()
    
    concatenate_repository(args.repo_path, args.output, args.max_size)

if __name__ == "__main__":
    main()

================================================================================
FILE: generate_concat.bat
SUMMARY: Type: bat file
================================================================================

@echo off
cd /d "D:\your\folder\path"
python concatenate_repo.py "D:\RA\summ-pages"
pause

================================================================================
FILE: index.md
SUMMARY: Type: md file
================================================================================

---
layout: default
title: Home
---

## The Principle of Scannability

Good web design allows users to scan a page quickly to find what they're looking for. Long blocks of text can be intimidating. Marginalia, or sidenotes, help break up the text and provide quick summaries for the reader.
{% include sidenote.html text="Scannability & Sidenotes" %}

This system works by using a Jekyll include. The include tag inserts a small piece of HTML into the final page. Our CSS then sees this new HTML element and uses a Grid layout to position it in the left-hand column, next to the paragraph it's associated with.
{% include sidenote.html text="Jekyll, CSS Grid, Layout" %}

On mobile devices, a two-column layout doesn't work well. Our CSS includes a special rule called a media query. If the screen is too narrow, it automatically switches to a single-column layout and styles the sidenote as a simple, indented quote above the paragraph.
{% include sidenote.html text="Responsive & Mobile" %}

## Book Notes

Here you can find summaries and notes on various books.
{% include sidenote.html text="Reading List" %}

<p>
  <ul>
    <li><a href="{% link books/lieberman.md %}">Summary of "The Story of the Human Body"</a></li>
  </ul>
</p>


================================================================================
FILE: README.md
SUMMARY: Type: md file | Purpose: Documentation/README
================================================================================

Site is live at https://danielkerschke.github.io/summ-pages/


================================================================================
CONCATENATION COMPLETE
================================================================================
Files processed: 9
Files skipped: 0
Total content size: 41,123 characters
